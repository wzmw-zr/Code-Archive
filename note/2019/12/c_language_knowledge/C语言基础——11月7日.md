

## 一、宏定义

### 1.基本宏定义

```c
#define PI 3.14
#define EPSILON 1e-6
```

### 2.带参数的宏定义

```c
#define MAX(a,b) a>b?a:b
```

每当程序里面出现MAX(x,y)这样形式的内容时，它所在的位置就会被替换为x>y?x:y。请注意，我们使用了不同的字母，就是希望你知道，在圆括号内，我们传入的是参数。

宏定义结束的时候都是没有括号的。

宏定义会在编译前被预处理，所以它的替换过程并不会占用程序运行时的时间。对于一些可被配置，在程序中不会被修改的量（如数组长度）和结构，我们都极为推荐使用宏定义的方式来进行设计。



## 二、数组与内存

一个数组其实与一系列同类型的变量类似。变量在内存中有自己的地址，我们可以通过&得到它。而对于数组来说，它的每一个元素也有着自己的地址，更为有趣的是，数组在内存中会占用一个连续的区域，所以它的每一个元素的地址也是相邻的。

与取变量地址的方式一致，我们可以通过&a[0]的方式取得数组a在索引位置 0 元素的地址。因为我们声明数组时的类型是int，相应地，我们也可以声明一个int *p变量来存储&a[0]的地址：

```c
int *p;
p = &a[0];
```

进行下面的输出：

```c
printf("%d", *p);
```

我们会得到`a[0]`的值。

在 C 语言中，定义了一种在地址上进行运算的方式，如果我们已经有了上面列出的语句，这时候如果通过printf("%d", *(p+1));或printf("%d", *(&a[0]+1));进行输出，我们都会得到a[1]元素的值，因为p+1和&a[0]+1的这种计算实际上都会得到a[1]元素的地址。 类似的，p+2、&a[0]+2或&a[1]+1都会得到a[2]元素的地址。



在 C 语言中，无论数组内的元素是什么类型的，对一个元素的地址加一个位移值 nn 得到的就是这个元素往后数 nn 后所在元素的地址。 一般来说，我们通过在地址上进行运算的方式访问数组的效率是比用数组索引的方式执行更快的。同时，它在一些特殊场景下也会让你写起来觉得很方便。例如，当你只希望访问数组中的每一个元素一次时，你可以通过在一个while循环内使用地址上运算的方式使用数组中每一个元素的值，而无需去关心数组的索引是谁……

```c
// 举个例子方便你直观理解
int n = 3;
int a[3] = {1, 2, 3};
int *p;

p = &a[0];
while (n != 0) {
    n--;
    printf("%d\n", *p);
    p++;
}
```



## 三、字符数组与字面量

在 C 语言中，提供了一种字符数组初始化的简化方式。

```c
//字符数组比较麻烦的初始化方式
char string[] = {'H', 'e', 'l', 'l', 'o', '\0'};
//字符数组的初始化的简化方式
char string[] = "Hello";
```

“字符串”实际上是被更为严谨地称为 字符串字面量（string literal），字面量（literal） 并非仅包含字符串字面量。

例如整型字面量：

```c
int a;
a = 1234;
```

这个语句中的1234其实就是一个整数型字面量，在这个赋值过程中，我们实际上是将一个整数型字面量的值放入了一个整数型变量中作为值。

在字面量后，我们往往会增加一个后缀标记类型。

1. 长类型（long）字面量，我们会加一个l或L，例如1234L。 
2. 无符号字面量（unsigned）以字母u或U作为后缀，例如345U。
3.  后缀f或F则用于标记单精度浮点型（float）字面量，例如3.14F或1e-2f。不增加后缀的浮点型字面量均为双精度浮点型（double）字面量。

对于整数型字面量，除了我们日常使用的十进制之外，我们还可以用八进制和十六进制对它进行表示。

例如，我们可以将十进制的25写为八进制的031，也可以写成十六进制的0x19或0X19。 同时，后缀L、U、F在这里依然可以使用，例如0XEUL就是一个十六进制表示的无符号长浮点数，它的值与十进制中的14相等。

## 四、另一种字符串

除了用字符数组去存储字符串，我们还可以声明一个用于存储字符地址的变量操作字符串。

```c
#include <stdio.h>

int main() {
    char string[] = "Hello";
    printf("%s\n", string);
    char *string2 = "Hello";
    printf("%s\n", string2);
    printf("%p\n", &string);
    printf("%p\n", string2);
    printf("%p\n", &"Hello");
    return 0;
}
```

第二种写法的输出结果和第一种字符数组的没有什么区别。 但是，它们的工作原理是不同的，`char *string2 = "Hello"`;的写法实际上是在`string2`这个变量中保存了"Hello"这个字符串字面量在程序运行时在内存中的地址。 同时，请注意，因为"Hello"是一个字符串字面量，所以我们也是没有办法直接通过`string2`来对字符串做修改的。



最后我们实际上通过三个输出语句，分别输出了`string`这个字符数组在内存中的地址、`string2`所存的地址、`"Hello"`字符串字面量所在内存中的地址。 点击 运行，发现`string2`所存的地址和`"Hello"`字符串字面量所在内存中的地址是一致的。 发现`string`的地址和`string2`的地址是完全不同的。其实你看到的`string`的地址是内存栈区的地址，而`string2`则是直接关联到`"Hello"`字符串字面量在内存中字面量池中的地址。



## 五、二维数组

每一个二维数组其实都可以被看作由特定数量的一维数组组成。我们可以通过如int m\[2\]\[3\]的形式进行声明。

在声明二维数组时，我们在**第一个方括号内写的数字可以被视为一维数组的个数**（如这里的[2]），我们也**可以称之为“行号（row）”**；我们在**第二个方括号内写的数字可以被视为是每个一维数组内的元素个数**（如这里的[3]），我们也**可以称之为“列号（column）”**。

我们在访问数组元素时，方括号内写的数字分别表示数组中的元素在行和列的编号，也可以称为“行索引”、“列索引”。

**二维数组和一维数组一样，也可以在声明的时候完成初始化过程。**只不过，**二维数组的初始化会有两层大括号**，==外层的大括号包裹了多组内括号包裹的一维数组元素，之间用逗号进行了分隔==。

```c
int m[2][3] = {{2，4，5}，{4，7，9}};
```

二维数组在内存中是连续存储的。从m\[0][0]开始，内存中在它之后紧接着的是元素m\[0][1]的空间，再之后是元素m\[0][2]的空间；在所有m\[0][?]（问号表示任何可能的索引）的空间之后，紧接着的就是m\[1][?]的元素所占的内存空间，依次被m\[1][0]，m\[1][1]，m\[1][2]所占用。

 **从内存的角度来看，我们也可以将二维数组看作一种特殊的一维数组。我们也是可以通过地址上运算访问二维数组中的元素的。**



## 六、字符串输入与输出

第一种做法很显然就是我们之前已经使用过很多次的`scanf`。在这里，我们希望接收一个字符串到string这个变量。第一种做法很显然就是我们之前已经使用过很多次的`scanf`。在这里，我们希望接收一个字符串到string这个变量：

```c
scanf("%s", string);
printf("%s\n", string);
```

在这里，我们写的并不是&string而是string。因为**在C语言中，数组名直接可以被当做数组所在内存的地址使用**。

当你输入hello world时，被输出的只有hello。这是**因为scanf在遇到空格时就已经终止读入了。**

当输入的字符串长度超过我们声明的字符数组长度，会报Segmentation Fault（段错误），我们已经在程序运行时，让它写入了“不属于它”的内存空间。



## 七、输出到字符串

标准输入输出库中的`sprintf`函数，它的功能是将格式化的数据写入到一个字符串。

```c
#include <stdio.h>

int main() {
    char information[100];
    char *name = "Li, Lei";
    char *gender = "male";
    int age = 14;
    float height = 187.5f;
    // 请在这里使用 sprintf
    sprintf(information, "%s is a %s", name, gender);
    printf("%s", information);
}
```

通过这种方式，我们将格式为"%s is a %s"的一个输出写入到了information中，其中两个占位符分别被name和gender所替换。

可以将其他类型的变量也加进来，如：

```c
sprintf(information, "%s is a %s. He is %d-year-old and %fcm tall", name, gender, age, height);
```

在information这一字符串中写入了一个格式化输出的结果，依照字符串格式描述，一系列int、float等类型的数据被“嵌入”到了格式字符串的占位符位置，并最终写入到了information中。

`sprintf`可以被我们广泛地应用于各种数据的格式化，**第一个参数是被写入的字符串，第二个参数是写入的格式，之后的参数是依次会被写入的数据。**

我们一定要**注意用于第一个参数的字符串声明时的长度**，如果它所对应的**内存空间**不足，我们现在的这种用法就可能会触发段错误。

> `sprintf`可以解决`scanf`输入字符串时遇到空格就停止的不足。



## 八、字符串长度

C 语言中有一个专门用于处理字符串的标准库，我们可以通过`#include <string.h>`的方式将其引入。在这个标准库中提供了一个函数`strlen`（表示 string length）用于获得字符串的长度。 先加上`string.h`引入处理字符串的标准库。



## 九、字符串拷贝

在处理字符串的标准库中，有一个函数strcpy（表示 string copy）用于复制字符串。

```c
#include <stdio.h>
#include <string.h>
int main() {
    char string[100];
    char copy[100] = "";

    scanf("%s", string);
    // 请在这里将 string 的内容复制到 copy 字符串中
	strcpy(copy, string);
    printf("%s\n", copy);
    return 0;
}
```

`strcpy`函数的**第二个参数是被复制的字符串**，而**第一个参数则是需要复制到的目标字符串变量位置**。

当我们在程序中通过`strcpy`完成了复制的过程后，copy中就和string中的字符串是一致的了。 

不过需要注意一下，我们**在使用`strcpy`时要确保目标字符串的声明长度可以装得下，否则程序运行时则可能会出现段错误。** 

为了避免这一问题，我们在工程中更多的**鼓励大家使用增加了第三个“复制长度”参数的`strncpy`函数。**



## 十、字符串字典序

C 语言中对于字符的比较依赖的是字符的编码，C 语言中默认使用了 ASCII（American Standard Code for Information Interchange，美国标准信息交换码）作为编码标准，每一个字符都对应了一个整数值。

通过参考列出的 ASCII 码参考表（局部），**在 C 语言中，字符直接进行大小的比较时，会对它们的编码值进行比较。**因此，我们可以知道'A'是小于'B'的，'A'是小于'a'等。

在 C 语言中，我们通常遵循的是一种特殊的定义——字典序（lexicographical order）。

> ==**对于字符串`"abc"`和`"bbc"`的大小关系**==——我们首先会对它们的第一个字符进行比较，我们发现第一个字符'a' < 'b'时，我们就可以明确`"abc" `< `"bbc"`的结论。 
>
> ==**对于字符串`"abc"`和`"abd"`的大小关系**==——我们首先会对它们的第一个字符进行比较，如果第一个字符相同，则会接下来比较第二个字符；如果第二个字符相同，则会接下来比较第三个字符，当我们发现第三个字符'c' < 'd'时，我们就得到了`"abc"` < `"abd"`的结论。 
>
> ==**对于字符串`"abc"`和`"ab"`的大小关系**==——我们首先会对它们的第一个字符进行比较，如果第一个字符相同，则会接下来比较第二个字符；如果第二个字符相同，则会接下来比较第三个字符，当我们发现"ab"没有第三个字符时，我们就得到了`"ab" `<` "abc"`的结论。

### (一)字典序规则

1.字典序遵循的是逐字符比较的方式，越靠左的字符越会被先比较。

2.逐字符比较过程中，一旦发现某一对被比较的字符之间不相等时，这一对字符的大小关系即为这一对字符串的大小关系。

3.逐字符比较过程中，一旦出现某一个字符串的所有字符都已经经过比较，而另一字符串还存在未被比较的字符时，较短的字符串更小。 

4.如果所有字符串内的字符都被发现相等，则这两个字符串相等。



## 十一、字符串比较

在处理字符串的标准库中，有一个函数strcmp（表示 string compare）用于比较字符串。

```c
#include <stdio.h>
#include<string.h>

int main() {
    char string[100] = "hello";
    char input[100] = "";

    scanf("%s", input);
    // 请在这里输出 string 和 input 比较的结果
    printf("%d\n", strcmp(input, string));
    return 0;
}
```

**当input小于string时返回了负数，当input等于string时返回了 0，当input大于string时返回正数**。

可以之阿`if`的条件里写：

```c
strcmp(input, string) == 0
```

来判断两个字符串是否相同。



## 十二、字符串连接

在处理字符串的标准库中，有一个函数strcat（表示 string concatenation）用于连接字符串。

将world连接到hello的后面可以通过`strcat(hello, world)`的方式实现。

strcat函数将第二个参数的字符串（含\0）拷贝到第一个参数的字符串\0所在内存位置及之后。所以，我们通过`strcat(hello, world)`就会改变hello的值，让"hello "之后多出了"world"这段字符串。

类似于strcpy函数，在使用strcat函数时，我们也要注意内存安全的问题。如果被连接上新内容的目标字符串的声明长度不够长，我们程序在运行的时候就可能会出错了。相应地，工程中我们也更鼓励大家使用增加了第三个“追加长度”参数的strncat函数。