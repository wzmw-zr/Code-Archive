

## 一、指针与内存

在 C 语言中有一类变量，它们被我们称为 指针（pointer） 或 指针变量（pointer variable）。

其实，指针变量最不同于其他变量的地方，就是它存储的是某一块内存的地址，而其它变量直接存储的是值。

```c
int *p;
p = &a;
```

变量p其实就是一个指向整数型变量内存空间的指针变量，在其中存的就是a这个整数型变量的内存地址。

```c
void swap(int *a, int *b);
```

声明的函数的形式参数a和b也是两个指向整数型变量内存空间的指针变量。当这个函数被调用时，两个相应的地址就会被作为实际地址传入，分别被保存在指针变量a和指针变量b中，并在函数内使用。

```c
int a[3] = {1, 2, 3};
int *p;
p = &a[0];
```

声明的一个指针变量p保存了数组a首元素的地址，指向了数组a的首元素。我们通过在地址p上+1或者-1进行了运算，而这其实也就是使指针变量内存储的地址发生了改变，使指针指向了向前一个或者向后一个数组内元素。

```c
char *string2 = "Hello";
```

在这里的`string2`实际上也被称为指针，只不过这里是一种字符指针在`string2`中存储了一个程序运行时"Hello"这个字面量在内存中一个“字面量池区”的地址（请注意，“字面量池区”与我们之后会介绍到的“栈区”、“堆区”和“全局区”都没有包含关系）。

C 语言的编译器会根据指针的类型决定指针指向的对象的长度。 例如：int *类型的指针会从指定地址向后寻找 44 个字节作为变量的储存单元；double *类型的指针会从指定地址向后寻找 88 个字节作为变量的储存单元。

**加上指针变量名表示取指针地址所储存的值。**

**字面量是一个指针，但是不是变量。**

**指针变量指向的是内存地址，但是指针变量不等于内存地址。**



## 二、动态分配内存

C 语言程序在编译时会被分配到内存上的一片有限的连续区域，这部分内存会被用于存储局部变量（在某一个函数内声明的变量）的值。**我们平时声明局部变量、给局部变量赋值的时候就在使用这部分的内存**。这部分的内存区域被我们称为——**栈区（stack）**。

 相对应的还有一片区域叫做 **堆区（heap）**，这部分的内存是我们**通过程序手动地向系统申请**的。栈区内存大小编译时就已经被限制，如果使用超过限制的内存就会出现“溢出”的情况，而堆区的内存可以一直被申请、使用，直到操作系统中的有效内存无法再被申请为止，相比之下，堆区控制起来更为灵活。

 除此之外，还有一块 **全局区（或为静态区，static storage area），程序中的全局变量和静态变量都被存储在这块内存区域中。**这块内存我们既不说它是“栈区”，也不说它是“堆区”。

正是因为栈区上内存大小受限的缘故，在内存需要比较大的（超出栈区限制）的情况下，我们会需要申请堆区上的内存。但是，堆区被申请后，在使用的过程中若不释放就可能会出现“内存泄漏（memory leak）”。

 如果我们需要使用堆上内存，我们就会需要将`malloc.h`或`stdlib.h`引入到程序中来。在这两个标准库中，都定义了申请、管理堆区上内存的函数。

引入必要的标准库之后，我们可以通过

```c
int *p;　
//malloc是memory allocation的缩写，意为动态内存分配
p = (int *) malloc(sizeof(int));
```

的方式声明一个整数型的指针`p`，向系统申请堆区上`sizeof(int)`（表示一个整数型变量所需的内存空间大小）的一块内存空间，并将指针p赋值为这片空间所在的起始地址，使得p指向这片空间。

在这里，**`malloc`返回默认为void *（无类型指针）类型**，**在`malloc`之前添加的(int *)会将这片内存空间的起始地址标记为整数型的地址，使之与整数型的指针变量相匹配，**否则编译器就会说出现了类型不匹配的问题，不让你的程序通过编译。

如果要修改栈区内存空间中的值，因为p是一个指针变量，写\*p = 4的话我们将修改存储地址。**要对值进行修改，则需要使用之前学过的取值符号\*，采用\*p = 4的方式修改它指向的空间内存储的值。在这一点上，堆区空间与栈区空间是相同的**



## 三、动态申请数组

```c
//第一种方式：
int *arr = (int *) malloc(n * sizeof(int));
//第二种方式：
//calloc全名clear allocation，意为动态分配内存并做初始化
int *arr = (int *) calloc(n, sizeof(int));
```

`calloc`与`malloc`主要有两点不同：

1. `calloc`函数申请的内存空间是经过初始化的，全部被设成了0，而不是像`malloc`所申请的空间那样都是未经初始化的。 
2. `calloc`函数适合为数组申请空间，我们可以将第二个参数设置为数组元素的空间大小，将第一个参数设置为数组的元素数量



## 四、堆上内存的释放

在之前的课程中，我们已经学习过，从堆区上申请的内存如果使用后没有被释放，将会造成内存泄漏。

如果我们动态申请了数组arr，则需要使用free(arr)释放arr数组指向的被分配的堆区上的空间。 

这样，我们就将arr指向的堆区内存空间释放回系统了。 但是，这还没有结束。为了**避免我们错误地使用arr指针，再次触碰到那个已经不应该再被我们访问的地址对应的内存。我们将这个叫arr的指针数组指向一个叫NULL的位置，使之成为一个空指针**。`arr = NULL;`



## 五、指向指针的指针

声明了一个指针变量p并且让它指向了整数型变量a。

从内存上来想，指针变量p也是保存在内存里的，所以它的地址也应该是可以通过&p获得到的。让我们在p指向a之后写下

```c
#include <stdio.h>

int main() {
    int a = 4;
    int *p;
    p = &a;
    int **q;
    q = &p;
    return 0;
}
```

int \*\*q;帮助我们声明了一个指向int \*类型变量的指针。而&p取出了指针变量p在内存中的地址，q = &p;让我们把指针变量p所在内存地址存到了指针变量q中，让指针q指向了指针p。 这时候，如果我们输出q我们应该得到的是指针变量p的地址，如果我们输出*q我们应该得到的是指针变量p存储的值，也应该就是变量a的地址。

我们可以明确一点，取值符\*是可以连续使用的，所以\*\*q的这种写法是合法的。而且这种写法也的确表示通过*q取出的值作为地址再进行一次取值。



## 六、无类型指针与类型转化

`malloc`函数的返回值类型为void *。这是一种特殊的指针类型，任何一个其他指针变量都可以被直接赋值给void *类型的指针，例如：

```c
void *vp;
int *p;
p = &"123";
vp = p;
```

就是合法的一种写法。但是如果我们反过来，直接将无类型指针赋给一个其他类型的指针变量，则必须要在前面加上被赋值指针变量的类型，如(int *)。

通过(int *)这种方式使得值的类型发生改变的方式被称为 强制类型转换（explicit type conversion）。

```c
float num = 2.3f;
printf("%d\n", (int) num);
```

会将一个浮点型的变量在输出时强制转换为整数型的变量。在这里，包围了**int的圆括号()被称为 类型转换运算符**，他可以将之后的数值（变量、字面量或者函数的返回值等）强制变为括号内说明的类型。

除了强制类型转换外，在混合了多种不同类型的运算中，还存在一种 **隐式类型转换**（implicit type conversion 或 type coercion）。 

如果一个运算（和一个运算符关联）中，**参与运算的数值类型不同，则会先转成同一类型，然后再进行运算**。 **隐式转换有一个固定的转换方向，尽可能保证数据的精度。**例如，int型会被转为long型，float型会被转为double型。 **赋值时，类型会以赋值号左侧为准，右侧的表达式的结果类型会被转为左边变量的类型。如果右侧表达式其实精度高于左侧的变量类型的精度时，一部分超出精度的数据将会丢失。**



## 七、位运算

在 C 语言中，不仅仅可以把这些字面量数值按照声明时的类型去看待，我们也可以把它们当成最本质的内存中的二进制存储来看待。

C 语言提供了直接对内存中每一个按位进行运算的操作符，使用按位运算可以将一个存储单位中的各个二进制位左移或右移一位，也可以将一个存储单位中所有的二进制位取反，这些操作多数要比直接进行数值上的运算要高效不少。

在 C 语言中，有如下几种位运算： 

1.**按位取反（bitwise NOT） 运算**，也就是将每一位是 11 的变成 00，是 00 的变成 11。这一运算的运算符为~： 二进制的 00100010 按位取反为会得到 11011101 二进制的 00000000 按位取反后会得到 11111111

2.**按位与（bitwise AND） 运算**，在每一位上对 00 和 11 进行逻辑与运算。这一运算的运算符为&： 二进制的 10001000 和二进制的 00000000 进行按位与运算后会得到 00000000 二进制的 10001000 和二进制的 11001100 进行按位与运算后会得到 10001000 

3.**按位或（bitwise OR） 运算**，在每一位上对 00 和 11 进行逻辑或运算。这一运算的运算符为|： 二进制的 10001000 和二进制的 00000000 进行按位或运算后会得到 10001000 二进制的 10001000 和二进制的 11001100 进行按位或运算后会得到 11001100

4.另外还有一种位运算叫 **移位（shift） 运算**，它包括**左移运算、右移运算**两种，对应的**运算符分别为<<和>>**。 

由于一块分配好的内存位数是有限的，**左移运算发生时，这些内存中的最左位会被舍弃，最右位会被补 0**。 对二进制 10001000 进行左移，我们将得到 00000000 对二进制 00110011 进行左移，我们将得到 01100110 相应的，**右移运算发生时，这些内存中的最右位会被舍弃，最左位会被补 0**。 对二进制 10001000 进行右移，我们将得到 01000100 对二进制 00110011 进行右移，我们将得到 00010001



**在计算机中，数值以补码来表示。所有的位运算也都要先将数值从原码被变为补码后才能进行。**补码的最左位为符号位：正数的补码最左位的符号位为 0，其余位为数的原码二进制表示；负数的补码最左位的符号位为 1，其余位为原码二进制每位取反后再加 1。

### (一)按位取反`~`

在C语言程序中，只需要通过`~`运算符就可以进行按位取反操作。

```c
#include <stdio.h>

int main() {
    int number;
    scanf("%d", &number);
    printf("%08x %08x", number, ~number);
    return 0;
}
```

这里使用了`%08x`进行占位，其中%x表示以 1616 进制形式作为数字格式，在中间插入的08可以使得输出不足 88 个数字时，在左侧补 00 直到达到 88 位数字。



### (二)按位与`&`、按位或`|`



### (三)移位 `>>`,`<<`

其实每次左移一位的时候实际相当于被操作数乘以 2，而每次右移一位的时候实际上相当于被操作数除以 2（如果二进制形式最右位是 1，则每右移一位时相当于先减 1 再除以 2 了）。



C语言字符串类型的变量都是以`"\0"`结尾的。