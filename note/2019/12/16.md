# 2019.12.16

## 一、欧拉计划03——合数的因数性质

**题目描述：**13195的质数因子是5,7,13,29。数字600851475143的最大质数因子是多少？

**合数的因数性质：**
$$
对于任意一个合数n，均可以表示为\\
n = a * b\\
a, b > 1\\
假设a \le b,则\\
a \le \sqrt{n}\\
b \ge \sqrt{n}
$$
**结论一：**==质数与合数的判定定理==
$$
在[2, \sqrt{n}]范围内可以找到一个数字整除n的话，n是合数，否则n是质数。\\
在编程实现的过程中，可以使用i * i <=N作为判断条件。
$$

```c
#include<stdio.h>
#define N 600851475143LL //定义宏时，如果需要定义为long类型，则需要在数字之后加上LL
int main() {
    long ans = 0, M = N;
    long i = 2;
    while (i * i <= M) {
        if (M  % i == 0) ans = i; //ans一定是素因子
        while (M % i == 0) M /= i; //将当前素因子i的所有重复都去除，只留下比i大的素因子，因为在重复除i的过程中所有可能以i为因子的合数都不复存在(这是一种完全确保已经经过的部分永远不会再次出现的思想，类似的还有素数筛)
        i += 1;
    }
    if (M > 1) ans = M; //这里保证了能够将ans更新为当前最大的素因子， M>1是为了确保当前的M至少还有一个素数因子。
    printf("%lld\n", ans);
}
```





## 二、欧拉计划04——整数翻转

**题目描述:** 回文数是正读、反读都一样的数字。最大的由二位数的乘积获得的回文数是9009=91 × 99。寻找由三位数之间的乘积获得的最大回文数。

**方法一(直接翻转，不使用字符数组)：**

```c
//10进制下的整数翻转
int a = N, b =0;
while (a) { //这个while循环模拟了整数翻转的过程
    b = b * 10 + a % 10;
    a /= 10;
}


//n进制下的整数翻转
int a = N, b = 0;
while (a) {
    b = b * n + a % n;
    a /= n;
}
```





## 三、欧拉计划06——平方数之和

**题目描述：**计算$(1^2+2^2+...+100^2)-(1+2+...+100)^2$的值

**线性累加和公式：**
$$
\sum_{i = 1}^{n}i = \frac{n(n+1)}{2} \\
更加普遍的公式：\\
\sum_{i = k}^{n}i = \frac{(n+k)(n - k + 1)}{2}\\
推倒过程就是首位对称相加和相等，如此计算即可。
$$
**平方和累加公式：**
$$
\sum_{i = 1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}
$$
推导过程如下：
$$
n^3-(n-1)^3 = 3n^2-3n+1\\
(n-1)^3-(n-2)^3=3(n-1)^2-3(n-1)+1\\
(n-2)^3-(n-3)^2=3(n-2)^2-3(n-2)+1\\
...\\
1^3-0^3=3(1)^2-3(1)+1=1\\
将上述表达式左右分别累加：\\
n^3=3(1^2+2^2+...+n^2)-3(1+2+...+n)+n\\
1^2+2^2+...+n^2 = \frac{n^3+3(1+2+...+n)-n}{3}\\
即\sum_{i = 1}^{n}i^2=\frac{2n^3+3n^2+n}{6}=\frac{n(n+1)(2n+1)}{6}
$$



## 四、欧拉计划30——上界估算

**题目描述：**找到所有可以写作其各数位上数字的5次方的和的数字之和(1除外)。

**思路：**令数字位数为n，很明显，n的上界可以由各位数字的5次方和的最大值小于n位数字的最小值来限定。(这是一种"最大与最小限定"的思想)。

所以此处的上界可以由$f(n)=9^5*n$与$g(n)=10^{n-1}$之间的关系来确定。

![Figure_1](/home/zr/Desktop/HaiZei/Figure_1.png)