# 2020.1.17—文件与目录操作

## 一、目录

| 命令    | 功能             |
| ------- | ---------------- |
| `cd`    | 切换当前工作目录 |
| `pwd`   | 打印当前工作目录 |
| `mkdir` | 创建目录         |
| `rmdir` | 删除目录         |

> ```shell
> ln -s /mnt 
> # 在当前目录下建立名为mnt目录的软链接链接到/mnt目录
> ```
>
> 这样的话`pwd -L`的结果就是例如`/home/zr/mnt`，但是`pwd -P`的结果就是`/mnt`

> ```shell
> rmdir -p path
> # 如果这个目录的祖先在这一步删除操作后是空的，那么就会连带该父目录一起删除
> # 但是一般不要使用这个命令，太危险了。
> ```



## 二、文件与目录管理

| 命令       | 功能               |
| ---------- | ------------------ |
| `ls`       | 显示文件及目录信息 |
| `cp`       | 拷贝，以及重命名   |
| `rm`       | 删除               |
| `mv`       | 移动，以及重命名   |
| `basename` | 获取文件名         |
| `dirname`  | 获取目录名         |

> `mv`以及`cp`都可以进行重命名。

> ```shell
> sudo rm -rf ${DIR:~/tmp}/*
> #上面这行代码的功能是当DIRu不存在的时候，删除tmp目录下的内容
> #这样可以防止在写脚本时造成删库的结果
> ```

> `dirname`就是简单的处理字符串，获取最后一个元素(文件或者目录)的祖先目录路经。
>
> `basename`也是简单的处理字符串，最后输出最后的文件名或者目录名。
>
> 举例如下：
>
> ```shell
> basename ~/HaiZei/2020/1/1/
> #输出 1
> dirname ~/HaiZei/2020/1/1/
> #输出/home/zr/HaiZei/2020/1
> ```

> ```shell
> ls -ald <dir>
> # 加d表示读的就是目录本身的信息
> ls -al <dir>
> # 不加d表示读的是目录里的内容
> ```



## 三、修改文件时间与新建文件

### 1.文件的三个时间

`mtime`：内容数据改动时才更新这个时间

`ctime`：文件的权限，属性改动时才修改这个时间

`atime`：文件的内容被访问时，更新这个时间

> `ls -al`默认显示的是文件的数据修改时间`mtime`



### 2. 修改文件时间与新建文件

```shell
touch <file>
# 这个命令默认是创建一个新的文件
touch [-acdmt] <file>
# -a: 仅修改访问时间
# -c: 仅修改文件的时间，若文件不存在，不新建
# -d: 修改文件日期
# -m: 仅修改mtime
# -t: 修改文件时间[yymmddhhmm]
```



### 3.文件的隐藏属性

```shell
chattr [+-][ASacdistu] <file_or_dir>
# 这个命令一般只能在i超级管理员模式下执行
# A: 不修改atime
# S: 同步写入
# a: 只能增加数据
# c： 自动压缩，解压
# d: 不会被dump程序备份
# i： 不能删除，修改，建立连接
# s: 文件删除时，直接从磁盘删除，一般的删除仅仅是删除与数据之间的对应关系，这里的-s属性则是在删除时将数据一并删除，多用于对于敏感数据的处理上。
# u: 文件删除时，数据存储在磁盘中
```

> 关于同步写入：
>
> 内核缓冲区中的文件会在30s内，或者内核缓冲区需要合并两个对文件的操作，或者超时的情况下会将文件的修改内容写入磁盘。这个就是回写机制。
>
> 而同步写入是边写边写入。
>
> 而在回写机制的情况下，对文件的修改最先是存放在内存中的，当一个文件的内容哈没有来得及回写就发生了另一个修改，那么此时就是对内存中的数据进行修改，之后再写入磁盘。



```shell
lsattr [-adR] <file_or_dir>
# -a: 打印隐藏文件的的隐藏属性
# -d: 如果是目录，仅打印目录的信息
# -R: 递归
```



## 四、文件的特殊权限

| 权限                 | 作用的对象             | 效果                                                 | 格式占位符                            |
| -------------------- | ---------------------- | ---------------------------------------------------- | ------------------------------------- |
| `set_uid`            | 二进制程序文件，非脚本 | 用户在执行程序时获取程序所有者权限                   | s(这个就是代替了u用户对该文件的x属性) |
| `set_gid`            | 目录和二进制程序文件   | 用户能进入该目录时，就会把用户的有效组变为目录所属组 | s(放在group的权限内的原来的x属性处)   |
| `sticky_bit`(粘着位) | 目录                   | 在该目录下，用户只能删除自己创建的内容               | t                                     |

> 用法举例如下：
>
> ```shell
> chmod u+s file_name 
> # 使得用户在执行程序的时候获取程序所有者的权限
> chmod g+s file_or_dir
> # 用户能进入该目录时，就会把用户的有效组变为目录所属组
> ```

> 关于所属组与有效组：一般而言，一个目录或者文件在被创建的时候它的有效组通常就是所属组(换句话说就是一般而言，有效组也就是创建的那个用户)



## 五、命令与文件的查询

| 命令      | 功能                 |
| --------- | -------------------- |
| `which`   | 寻找执行文件         |
| `whereis` | 寻找特定文件         |
| `locate`  | 搜索文件(可部分查找) |
| `find`    | 多样化高级查找       |

### 1.which

which查找PATH路径下所有的可执行文件

### 2.`whereis`

```shell
whereis [-bmsu] <file_or_dir>
#-b: 只查找二进制文件
#-m: 只查找manual路径下的文件
#-s: 只查找source源文件
#-u: 查找其他文件
```

默认是找到`usr`目录下的`bin`，`man`，`src`路径下能找到的符合要求的文件。

### 3.locate(模糊定位)

```shell
locate [-ir] keyword
#-i: 忽略大小写
#-r: 后面可以接正则表达式
```

locate可以在i系统中寻找任意文件。但是在使用这个命令之前最好先执行一下

```shell
sudo updatedb
# 更新文件的查找索引，便于locate命令进行查找
```

> 相关文件：`/etc/updatedb.conf`这是一个配置文件，和`/var/lib/mlocate`这是一个数据库文件

### 4.find高级查找

```shell
find [PATH] [option] [action]
#举例如下
find / -perm 664 -type p -size 0 2>/dev/null -exec ls -alF {} \;
```

#### (1)与时间相关的参数

与时间相关的参数：`-atime`，`-ctime`，`-mtime`

```markdown
-mtime n: n天前的"一天之内"修改的文件
-mtime +n: n天之前，不包含n，修改过的文件
-mtime -n: n天之内，包含n，修改过的文件
其余的几个时间参数的使用也是同理
同时还有类似-mmin -mhour 这种用法
-newer file: 比file还要新的文件
```

#### (2)与用户或者用户组相关的参数

与用户或者用户组相关的参数：

```markdown
-uid n: 用户UID为n
-gid n: 群组GID为n
-user name: 用户名为name
-group name: 群组名为name
-nouser: 文件所有者不存在
-nogroup: 文件所在组不存在
```

#### (3)与文件权限及名称有关的参数

与文件权限及名称有关的参数：

```markdown
-name filename： 文件名为filename 
-size [+-] SIZE: 查找比SIZE大或小的文件
-type TYPE: f b c d l s p
f是普通文件，b是块设备(block)，c是字符设备(character),d是目录文件(directory)，l是链接文件(link)，s是套接字(socket)，p是管道文件(pipe)

-perm mode: mode刚好等于的文件
-perm -mode: 全部包含mode的文件
```

> `/dev/null`是一个垃圾桶，所有输入的内容都不见了

> `wc`命令是用来进行单词，行数等的统计的，比方说`wc -l`就可以进行行数统计

> ==按照文件名进行查找时，需要使用字符串来包括这个文件名或者简单的正则表达式==

> 由于我们是在bash中输入find的命令，所以最开始会执行的i是bash的解析，所以i有时碰到这种情况，我们就需要使用转义字符来对字符进行转义，举例如下：
>
> ```shell
> find ./ \( -name "*.c" -o -name "*.cpp" -o -name "*.sh" -o -name "*.h" \)\
> #其中\(\)中的内容是给find命令解析的内容， 并且由于规范，圆括号两侧的需要留出一个空格的间距， -o就是一个"或"的作用
> ```

> `umask`的功能就是权限的掩码，通常我们是以777为基数，即所有人可读，可写，目录的话还有可执行，减去这个umask对应的权限掩码就得到了真实的权限代码。