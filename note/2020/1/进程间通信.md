# 进程间通信

## 一、进程间通信

在前面的课程中我们已经学习了fork()，我们可以通过这个系统调用产生一个子进程，然后用exec()在子进程中执行另一个程序，在父进程中调用wait()等待进程运行完毕，但这样我们在父进程中只能获得进程的退出码，这之外的数据我们就无法获得了；而随着子进程的终止，子进程的地址空间也会被系统回收，我们就更无法获得它的数据了。

为了能够读取这个数据，我们只有把它存储在一个两个进程都能读取、且不会随着进程的终止而被回收的存储位置，这个位置就是外存。

### 1.文件

文件是对外存中存储的数据的抽象，我们可以利用一个文件进行 `进程间的通信（Inter-process Communication，IPC`。进程 A 终止前将输出值写入这个文件，然后进程 B 再将这个文件的内容作为输入值读取进来，开始运行。这是进程间通信的一种常见方法；实际上，一段内存的共享也是通过将一个共享的文件同时映射到两个进程的地址空间实现的。

### 2.信号

另一种进程间通信的方法就是 信号（Signal）。信号类似于异常和中断，是异步的；进程在接到信号后在内核态通过对应的信号处理函数来处理该信号。在这一章中我们会先讲解系统对 I/O 和文件的处理，然后再以这些知识为基础去讲解通过文件进行进程间通信的方法，最后再讲到信号。



## 二、基本I/O操作

文件是对于外存中存储的数据的抽象，而外存实际上就是磁盘（disk），固态硬盘（SSD，Solid State Drives），磁带（tape）等物理存储设备。这些存储设备与鼠标、键盘、屏幕等无异，都属于 I/O 设备，你可以向这些设备里输入数据，或从这些硬件中获得我们想要的输出数据。因此，从文件中读取数据或向文件中写入数据实际都属于 I/O 的范畴。

操作系统给我们提供了非常便捷的抽象层——无论我们想要使用什么 I/O 设备，我们都可以调用同一组系统调用，这就是基本 I/O 操作。

### 1.`open()`系统调用

第一个系统调用是`open()`。它是用来打开一个文件的，在每次读写文件以前都必须调用这个函数打开文件，获得一个代表该文件的文件标识符，然后再对文件标识符进行操作。与你可能见过的`fopen()`相比，它处于系统中一个更低的抽象层，你可以对文件进行更基础的操作，但也失去了如`fgets(), fscanf()`这些方便的库函数的帮助。

```c++
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char* pathname, int flags, mode_t mode);
```

这个函数使用三个参数：

- `pathname`是被打开文件的路径；
- `flags`表示的是这次打开文件所需要进行的操作；
- `mode`可以被省略，只有在创建一个文件的时候才会被需要，表示的是新建文件的使用权限。

几个常用的 flags 的值包括表示创建文件的`O_CREAT`，表示访问模式的`O_RDONLY`, `O_WRONLY`, `O_RDWR`和表示写入模式的`O_APPEND`, `O_TRUNC`。 `O_CREAT`表示的是如果这个文件不存在，那么它就将被创建。文件的所有者是正在运行这个进程的用户，拥有这个文件的用户组是这个用户所在的组或这个文件的父目录所属的用户组。这两者对于mode中表示的模式很重要。 `O_RDONLY`是 read-only 的缩写，表示这个被打开的文件只能被读取，不能被写入；与它相反的是`O_WRONLY`，表示这个被打开的文件只能被写入，不能被读取。而`O_RDWR`表示的则是即可以读也可以写。 `O_APPEND`和`O_TRUNC`只有在文件允许写入时才有意义。`O_APPEND`表示从一个文件的末尾开始写入，而`O_TRUNC`则表示将文件清空。

`mode`表示的是被创建的新文件的使用权限，它有固定的格式：

- 前三位都是 S_I
- 从第四位开始表示权限
- 如果它表示只有一个权限，则第四位为该权限的缩写（R 表示 read，读，W 表示 write，写，X 表示 execute，执行），后三位为权限的对象（USR 表示 user，用户，GRP 表示用户 group，组，OTH 表示 others，其他用户）。
- 如果它表示三种权限都具备，那么第四位到第六位就是 RWX，最后一位表示权限的对象（U 表示用户，G 表示组，O 表示其他）。