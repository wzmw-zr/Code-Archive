# 进程间通信

## 一、进程间通信

在前面的课程中我们已经学习了fork()，我们可以通过这个系统调用产生一个子进程，然后用exec()在子进程中执行另一个程序，在父进程中调用wait()等待进程运行完毕，但这样我们在父进程中只能获得进程的退出码，这之外的数据我们就无法获得了；而随着子进程的终止，子进程的地址空间也会被系统回收，我们就更无法获得它的数据了。

为了能够读取这个数据，我们只有把它存储在一个两个进程都能读取、且不会随着进程的终止而被回收的存储位置，这个位置就是外存。

### 1.文件

文件是对外存中存储的数据的抽象，我们可以利用一个文件进行 `进程间的通信（Inter-process Communication，IPC`。进程 A 终止前将输出值写入这个文件，然后进程 B 再将这个文件的内容作为输入值读取进来，开始运行。这是进程间通信的一种常见方法；实际上，一段内存的共享也是通过将一个共享的文件同时映射到两个进程的地址空间实现的。

### 2.信号

另一种进程间通信的方法就是 信号（Signal）。信号类似于异常和中断，是异步的；进程在接到信号后在内核态通过对应的信号处理函数来处理该信号。在这一章中我们会先讲解系统对 I/O 和文件的处理，然后再以这些知识为基础去讲解通过文件进行进程间通信的方法，最后再讲到信号。



## 二、基本I/O操作

文件是对于外存中存储的数据的抽象，而外存实际上就是磁盘（disk），固态硬盘（SSD，Solid State Drives），磁带（tape）等物理存储设备。这些存储设备与鼠标、键盘、屏幕等无异，都属于 I/O 设备，你可以向这些设备里输入数据，或从这些硬件中获得我们想要的输出数据。因此，从文件中读取数据或向文件中写入数据实际都属于 I/O 的范畴。

操作系统给我们提供了非常便捷的抽象层——无论我们想要使用什么 I/O 设备，我们都可以调用同一组系统调用，这就是基本 I/O 操作。

### 1.`open()`系统调用

第一个系统调用是`open()`。它是用来打开一个文件的，在每次读写文件以前都必须调用这个函数打开文件，获得一个代表该文件的文件标识符，然后再对文件标识符进行操作。与你可能见过的`fopen()`相比，它处于系统中一个更低的抽象层，你可以对文件进行更基础的操作，但也失去了如`fgets(), fscanf()`这些方便的库函数的帮助。

```c++
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char* pathname, int flags, mode_t mode);
```

这个函数使用三个参数：

- `pathname`是被打开文件的路径；
- `flags`表示的是这次打开文件所需要进行的操作；
- `mode`可以被省略，只有在创建一个文件的时候才会被需要，表示的是新建文件的使用权限。

几个常用的 flags 的值包括表示创建文件的`O_CREAT`，表示访问模式的`O_RDONLY`, `O_WRONLY`, `O_RDWR`和表示写入模式的`O_APPEND`, `O_TRUNC`。 `O_CREAT`表示的是如果这个文件不存在，那么它就将被创建。文件的所有者是正在运行这个进程的用户，拥有这个文件的用户组是这个用户所在的组或这个文件的父目录所属的用户组。这两者对于mode中表示的模式很重要。 `O_RDONLY`是 read-only 的缩写，表示这个被打开的文件只能被读取，不能被写入；与它相反的是`O_WRONLY`，表示这个被打开的文件只能被写入，不能被读取。而`O_RDWR`表示的则是即可以读也可以写。 `O_APPEND`和`O_TRUNC`只有在文件允许写入时才有意义。`O_APPEND`表示从一个文件的末尾开始写入，而`O_TRUNC`则表示将文件清空。

`mode`表示的是被创建的新文件的使用权限，它有固定的格式：

- 前三位都是 S_I
- 从第四位开始表示权限
- 如果它表示只有一个权限，则第四位为该权限的缩写（R 表示 read，读，W 表示 write，写，X 表示 execute，执行），后三位为权限的对象（USR 表示 user，用户，GRP 表示用户 group，组，OTH 表示 others，其他用户）。
- 如果它表示三种权限都具备，那么第四位到第六位就是 RWX，最后一位表示权限的对象（U 表示用户，G 表示组，O 表示其他）。



## 三.文件描述与`dup()`

利用 open() 返回给我们的 文件描述符（file descriptor）。一个文件描述符就是一个整数，用来代表一个被打开的文件。==每个文件描述符都对应一个文件内指针==，表示这个被打开文件的实例中指针的位置，也就是说**如果一个文件被同一个进程打开了多次，那么这几个文件描述符中的指针位置可能是不同的**。

每个系统都对一个进程可以同时打开的文件数量有限制；每个进程都有一个由文件描述符指向文件的 **文件描述符表（file descriptor table）**。 open() 每次一般会把新打开的文件放到这个表格中的某个空行，然后返回这个文件描述符。需要注意的是，**这个文件描述符只是这个进程中代表这个这个文件的描述符，其它进程即使打开同一个文件也可能有不同的文件描述符；只有由 fork() 产生的子进程才会有和父进程一样的文件描述符**。

文件描述符从0 开始，但我们不能使用前三个文件描述符，因为它们是事先被规定好的： **0代表标准输入，1 代表标准输出， 2代表标准错误。**这三个文件描述符在进程初始时就已经被打开，你可以通过这些文件描述符从标准输入读取内容，或向标准输出和标准错误写入内容。

标准输出正是`printf()`输出的对象，而标准输入就是你在命令行中输入的内容，因此当我们想把一个进程的输出值导入到一个文件里的时候，我们只需要修改 1，2  这两个文件描述符，使他们输出到我们指定的文件中，我们再用其他进程来读取这个文件。这是就需要使用这个系统调用：

```c++
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

`dup2()` 能够使 `newfd `指向 `oldfd` 指向的文件；如果 `newfd` 本来对应着其他的文件，那么就关掉原来的文件，再使它指向 `oldfd` 指向的文件。通过调用 `dup2()` ，我们可以把标准输出和标准错误都关掉，而将 1，2文件描述符替换为我们想要的文件，这样 `printf()` 的内容就会直接导入到我们想要的文件里。

但是这样我们就面临着一个问题——如果我想在一段时间后重新向标准输出输出内容，那我该怎么重新把1 设定成标准输出呢？为了解决这个问题，我们需要另一个系统调用：

```c++
#include <unistd.h>
int dup(int oldfd);
```

`dup() `会选择最小的空闲文件描述符，使它指向 `oldfd `指向的文件，它返回的是新的指向这个文件的描述符。这样在调用 `dup2()` 以前，我们可以先用 `dup()` 复制一个指向标准输出的文件描述符，然后用 `dup2()`关闭原来的标准输出的文件描述符。
 在应用 `dup()` ， `dup2()` 和 `open()` 时，我们都不能忘掉检查函数调用确实成功——这三个函数在运行产生错误时，会返回 −1。



## 四、读写文件

在介绍了`dup()`之后，我们来介绍几个实际读写文件时非常实用的系统调用：`read()`，`write()`，`lseek()`，`fsync()`和`close()`。

### 1.`read()`函数与`write()`函数

读与写这两个系统调用所需的参数类似：

```c++
#include <unistd.h>
ssize_t read(int fd, void* buf, size_t count);
ssize_t write(int fd, const void* buf, size_t count);
```

它们的第一个参数都是`fd`，是 file descriptor 的缩写，是被读写的文件的文件描述符；第二个参数`buf`在read()中是用来存储读取的内容的，而在write中代表即将被写入的内容；最后一个参数count代表读写的 最大 长度,实际读写的长度可能少于count（比如读取文件时到达了文件的末尾，或写入文件时超过了系统允许的最大长度或资源上限）。==**如果调用成功，两个函数分别会返回实际读写的长度，否则函数会返回 −1**==。

### 2.`lseek()`函数

read()和write()的参数里有一个比较讨厌，就是count，因为我们不知道这个文件的长度，也不知道一行的长度，读起来就很困难。

一种做法是，一次把整个文件都读取到 buffer 中，然后再用处理字符串的函数来获得一行或单个的单词，但这就要求我们获得整个文件的长度。能够帮助我们**获得文件长度**的就是第三个系统调用，`lseek()`：

```c++
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

每个文件描述符都与一个文件内的指针联系在一起，这个指针会被读写文件改变，但我们也可以直接移动这个指针，这就是`lseek()`的作用。**`lseek()`的返回值是移动后指针的位置**。它的三个参数中，`fd`是被改变的文件描述符，`whence`是计算移动目标的起点，而`offset`就是从`whence`开始移动的长度。

whence有 3 个常用的值，SEEK_END，SEEK_SET和SEEK_CUR。SEEK_SET和SEEK_END分别代表文件的开头和结尾，而SEEK_CUR代表指针目前的位置。

> **每一个已打开的文件都有一个读写位置, 当打开文件时通常其读写位置是指向文件开头, 若是以附加的方式打开文件(如O_APPEND), 则读写位置会指向文件尾. 当read()或write()时, 读写位置会随之增加,`lseek()`便是用来控制该文件的读写位置. 参数`fd` 为已打开的文件描述词, 参数offset 为根据参数whence来移动读写位置的位移数.**

  SEEK_SET 参数offset 即为新的读写位置.
  SEEK_CUR 以目前的读写位置往后增加offset 个位移量.
  SEEK_END 将读写位置指向文件尾后再增加offset 个位移量. 当whence 值为SEEK_CUR 或
  SEEK_END 时, 参数offset 允许负值的出现.

> 下列是特别的使用方式:
> 1) 欲将读写位置移到文件开头时:`lseek(int fd, 0, SEEK_SET)`;
> 2) 欲将读写位置移到文件尾时:`lseek(int fd, 0, SEEK_END)`;
> 3) 想要取得目前文件位置时:`lseek(int fd, 0, SEEK_CUR)`;

==**返回值：当调用成功时则返回目前的读写位置, 也就是距离文件开头多少个字节. 若有错误则返回-1, `errno` 会存放错误代码.**==

### 3.`fsync()`函数

当我们完成了读取文件数据和向文件写入数据的操作后，我们需要注意一点，那就是我们写入的数据可能没有实际被写入磁盘！向外存中写入数据是很花时间的，因此内核为了提高效率会推迟实际写入数据。为了确保我们的数据确实进入了外存，我们需要调用`fsync()`：

```c++
int fsync(int fd);
```

这个函数在成功调用时返回0,否则返回-1。

### 4.`close()`函数

最后，在完成对文件的所有操作后，一定要记得关掉这个文件。在系统中如果有多个进程同时打开了一个文件，而其中一个进程删除了这个文件时，打开这个文件的进程不能突然产生错误，因此内核需要统计一个文件被多少个进程打开，在使用这个文件的进程数为零后再回收这段内存。为了使内核知道我们要将不再使用这个文件，我们需要调用close()：

```c++
int close(int fd);
```

