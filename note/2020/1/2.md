# 2020.1.2—宏定义总结

## 一、宏的定义

### (一)没有参数的宏

没有参数的宏定义的格式：

```c++
#define 宏名称 替换文本
```

### (二)带参数的宏

可以定义带参数(**形参**)的宏。==当预处理器展开这类宏时，它首先使用调用宏时指定的实际参数(**实参**)取代替换文本中的形参。==带有形参的宏又称作**类函数宏**。

#### 1.带有参数的宏的定义

```c++
#define 宏名称([形参列表]) 替换文本
#define 宏名称([形参列表，]...) 替换文本
```

"形参列表"是使用逗号隔开的多个标识符，他们作为宏的形参，**当使用这类宏的时候，需要确保实参列表中的实参数量必须与形参列表中的形参个数一样多**，这里的省略号意味着一个或者更多的额外形参。

> 当定义一个宏的时候，必须确保宏名称与与左括号之间没有空白符。



#### 2.字符串化运算符`#`

一元运算符`#`常被称为字符串化运算符。**它会把宏调用时的实参转换为字符串。**==`#`的操作数必须是宏替换文本中的形参。==

当形参名称出现在替换文本中，并且具有前缀`#`字符时，预处理器会把与该形参对应的实参放到一对双引号中，形成一个字符串字面量。(**这里的实参是直接实参，没有经过展开的那种**)



#### 3.记号粘贴运算符`##`

`##`运算符是一个二元运算符，可以出现在所有宏替换的文本中。该运算符会把左右操作数结合在一起，作为一个记号，因此被称为记号粘贴运算符。==如果结果文本中还包含有宏名称，则预处理器会继续进行宏替换，出现在`##`运算符前后的空白符连同`##`运算符一起被删除。==

通常，使用`##`运算符时，至少有一个操作数是宏的形参，在这种情况下，**实参值会先替换形参，然后等记号粘贴完成后，才进行宏展开。**

>在字符串化运算符`#`和记号粘贴运算符`##`的处理中都是首先将直接实参替换掉形参，之后才进行宏展开。而如果是没有这两种运算符的话，就会不断地进行展开直至完毕才进行替换。

>==宏不能递归展开==，**如果预处理器在A宏的替换文本中又遇到了A宏的名称，或者A、B宏互相调用，那么宏的名称就会无法展开。**



#### 4.宏的作用域和重新定义

我们无法再次使用`#define`命令重新定义一个已经被定义为宏的标识符，除非重新定义所使用的替换文本与已经被定义的替换文本完全一样。如果该宏具有形参，重新定义的形参名称必须与已经定义的行惨名称一样。

**如果想改变一个宏的内容，那么必须首先使用下面的命令取消现在的定义：**

```c++
#undef 宏名称
```

>当某个宏首次遇到它的`#undef`命令时，它的作用域就会结束，如果没有关于该宏的`#undef`命令，那么它的作用域在该翻译单元结束时停止。



## 二、条件式编译

条件式编译区域以`#if`,`#ifdef`,`#ifndef`等命令作为开头，以`#endif`命令结尾，条件式编译区域可以有任意数量的`#elif`命令，但是最多只能有一个`#else`命令。



## 三、常见的预定义的宏

```c++
__DATE__:当前日期
__TIME__：当前时间
__FILE__：当前文件
__LINE__：当前行号
__func__：所处函数名
__typeof(a): a的数据类型
```



## 四、代码实例

```c++
#include <stdio.h>
#include <stdlib.h>
// 使用宏定义生成代码，则需要使用括号和花括号将代码段括住，并且宏定义中的函数是没有返回值的，因为它并不是函数调用
#define MAX(a, b) ({\
    __typeof(a) __a = (a);\
    __typeof(b) __b = (b);\
    __a > __b ? __a : __b;\
})

#define Plog(frm, arg...) ({\
    printf("[ %s : %d ] ", __func__, __LINE__);\
    printf(frm, arg);\
    printf("\n");\
})

void haizei_test() {
    int a = 6;
    Plog("%d", MAX(2, 3));
    Plog("%d", 5 + MAX(2, 3));
    Plog("%d", MAX(2, MAX(3, 4)));
    Plog("%d", MAX(2, 3 > 4 ? 3 : 4));
    Plog("%d", MAX(a++, 6));
    Plog("a value = %d", a);
}

int main() {
    haizei_test();
    return 0;
}
```

