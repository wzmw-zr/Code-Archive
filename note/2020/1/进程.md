# 第三章 进程

## 一、进程、地址空间与线程

由于计算机所拥有的物理资源有限，当多个程序在计算机上同时运行时，它们不可能连续地在处理器上运行或占用全部内存，因此我们需要进程的抽象在用户的一侧隐藏上下文切换等细节。

**进程作为运行的程序的抽象，包含了一个程序的运行状态和这个程序所用的抽象内存及其中存储的数据。**我们将后一部分，即**一个进程可以使用的全部内存的地址和它们存储的数据，称为这个进程的 地址空间**（address space）。我们==可以将进程笼统地看做是一个或多个线程与一个地址空间的结合。==

一方面，进程的结构必须能够囊括一个进程的运行状态，在由于中断、异常或系统调度进入内核态时我们应该能够将进程的运行状态放入内存中的某一位置，使我们可以在某一个时间点根据进程的优先级接着这次的进度再次运行该进程；另一方面，由于进程在用户一侧对内存进行了抽象，我们需要在系统一侧包含从抽象内存向实际内存和外存（磁盘等存储设备）的映射，以便通过抽象内存的地址获得物理地址和其中存储的数据。

为了实现在进程中存储其运行状态，我们将在进程中存储处理器状态寄存器、指令计数器、栈指针、通用寄存器等代表了进程目前的运行状态的值。

由于现代计算机中往往有多个核或多个处理器，我们的程序可以达到并行（parallelism，即在物理时间上同时运行，区别于多个进程在处理器上的并发（concurrency）），**因此同一个进程可能同时包含有多个不同的运行状态。**

为了更好地区分进程在一个处理器上的运行状态和进程本身的运行状态，我们在此引入 线程（thread） 的概念。**每个线程拥有一个 线程控制块**（thread control block, `TCB`），用来存储我们上述提到的处理器状态寄存器、指令计数器、栈指针、通用寄存器等数值，**但同一个进程中的所有线程都共享同一个地址空间。**

一个用户进程所看到的内存空间是抽象的，区别于实际的物理内存，因此为了支持进程从抽象内存获取物理内存中存储的信息，我们需要在进程中包含从抽象内存向物理内存的映射，即该系统所用的地址转换方法所需要的信息。**地址转换有很多种不同方法，包括分页存储、分段存储等**，它们都需要不同的信息来实现地址转换。

在 Base and Bound 方法中，系统将一段连续的物理内存分配给一个进程，Base 代表基地址，即系统分配给一个进程的可用内存的起始地址，Bound 代表这个进程可用的内存的最高地址。为了读写物理内存，我们将基地址与抽象内存地址相加，获得实际地址；只要实际地址不大于 Bound，内核就会允许进程进行该操作。因此在这个方法中，为了实现进程地址空间的抽象，进程在系统一侧的数据结构中必须包括这段可用的内存的基地址、可用长度。

为了能在一个进程开始运行的时候方便地载入上面提到的两方面的数据，我们需要一个数据结构来包含这些数据。这个数据结构就是 **进程控制块**（Process Control Block, PCB）。**对于内核来说，它是进程存在的唯一标识。**进程控制块中存储的信息除了上面提到的实现地址转换的信息和表示运行状态的线程信息以外，还包括了很多系统在调度进程时需要的信息，比如进程号、进程所处状态（我们将在下一节中更多地解释进程可能所处的状态与不同状态间的切换）、进程的优先级等等。需要注意的是，**我们不会将整个地址空间中包含的地址及其数据都存储在进程控制块里；我们只需要可以帮助我们从抽象内存地址获得实际物理地址的方法，而实际数据仍然存储在内存的对应位置中。**

由于==进程控制块中的信息包含了优先级、基地址、可用地址范围等用户进程不应该有权限修改的信息，**用户进程不应该有权限修改进程控制块**。因此我们将进程控制块存储在内核空间中。==



## 二、进程状态与用户态和内核态之间的切换

进程至少需要两个状态——运行态（running） 与 就绪态（ready）。进程在运行态中运行一段时间后被切换出去，排入就绪队列，等待继续运行。在三态模型中，进程还有一个状态，即 等待态（wait）。在这个状态中，进程在等待某一事件完成，不会被排入就绪队列，直到该事件发生后，进程才会被排入就绪队列，可能被选为下一个运行的进程。这一等待事件可能包括等待系统调用完成，等待获得某一个锁或收到某一信号量的信号等等。

处于就绪态的进程不会因为遇到任何事件而无法进入等待态；处于等待状态的进程在事件发生后考虑到优先级等问题，必须先回到就绪状态而不能直接运行。

除三态模型外，五态模型也是一种常见的进程状态转换模型。相比三态模型，五态模型多引入了 新建态（new） 和 终止态（exit）。新建态对应着进程被创建时尚未加入就绪队列的状态。为了建立一个新的进程，内核需要给进程分配资源（如：建立进程控制块）、建立必要的管理信息；在这个过程中，进程就处于新建态。相对的，终止态对应的是进程已经结束但尚未被系统撤销的状态。处于终止态的进程虽然已经结束，但其获得的资源还未被系统回收，因此系统仍然可以获得该进程结束时的信息。

定义这两种状态可以帮助我们避免一些我们不想看到的情况。比如，如果我们允许一个进程在获得全部资源以前就进入就绪队列，那么一个新进程可能在未获得全部资源前就开始运行，而产生错误。

同样的，如果一个进程 A 创建了另一个进程 B 而想要等待进程 B 运行完毕，从中获得一些信息，那么终止态的缺失可能导致进程 B 率先运行完毕后被系统撤销，使得进程 A 无法从进程 B 处获得任何信息。

UNIX 系统中，如果发生一个进程创建另一个进程的情况，那么在老进程从新进程获取信息前，新进程会一直停留在终止态；如果新进程终止后，仍在运行的老进程没有从新进程获取信息，那么新进程就会成为我们所说的“僵尸进程”，停留在系统内存中，导致系统变慢。

![img](http://res.jisuanke.com/img/upload/20160524/b49f9d2d90d601cb3ff832695ce1727592adba5b.png)



## 三、子进程与父进程(进程的创建)

为了产生新的进程，我们必须使用一个新的系统调用，fork()。

```c++
pid_t fork(void);
```

fork()被包含在`unistd.h`中。

这个函数不需要任何参数；它会直接创建一个新的进程，将现在运行的进程的处理器状态、地址空间直接拷贝到新进程中，因此新进程也会从fork()对应的指令开始运行。

我们称这个新进程为调用fork()的进程的子进程，称创建子进程的进程为父进程。

**fork()执行完毕后会返回一个进程标识 ID（`pid `= process ID），可以被用来区分父进程与子进程。**

**在父进程中返回的进程标识 ID 是新创建的子进程的进程标识 ID，而在子进程中返回的进程标识 ID 为 0。**==我们可以利用if语句判断进程标识 ID 是否为 0，从而使子进程与父进程执行不同的命令==。

**在语句`fpid=fork()`之前，只有一个进程在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程的几乎完全相同，将要执行的下一条语句都是`if(fpid<0)`。**

为什么两个进程的`fpid`不同呢，这与fork函数的特性有关。**fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次**，它可能有三种不同的返回值：
    1）在父进程中，fork返回新创建子进程的进程ID；
    2）在子进程中，fork返回0；
    3）如果出现错误，fork返回一个负值；

一个进程在运行结束或产生重大错误（如：企图越权使用内核的特权指令）后会被系统终止。但我们**在由fork()产生的子程序中也可以用exit()系统调用主动结束这个程序**。

```c++
void exit(int status);
```

exit()函数在`stdlib.h`头文件中；**它的参数status表示这个进程退出时的结束状态**,==如成功则为 0，否则为对应的错误数字==。当我们用这个函数结束一个子进程时，**status会作为子进程的结束状态被提供给wait()的第一个参数**。

```c++
pid_t wait(int *stat_loc);
```

wait()被包含在`sys/wait.h`中。

它的参数`stat_loc`，是一个可以被**用来储存等待的进程的结束状态值**（exit code，**一个代表子进程是否成功退出的整数；==如成功则为 0，否则为对应的错误数字==**） 的==指针==。

```c++
int status;
// status 就是存放子进程是否成功退出的整数，如果成功就变成0,否则变成对应的错误数字
// result是wait函数的返回值，正常情况下返回的是结束状态值的子进程的进程标识ID，如果在等待过程中出现错误，那么wait函数将返回-1,根据result判断
int result = wait(&status);
if (result == -1 || status != 0) {
    //...
}
```



**但我们也可以把这个设为NULL，函数仍可以正常运行**。

**wait()函数会使父进程的状态变为等待态**，直到父进程的所有子进程中的 一个 成功退出并返回结束状态值，父进程才可以进入就绪状态，准备继续运行；如果在wait()被调用时已经有可用的结束状态值，那么wait()会立即返回。

**wait()返回的值是返回结束状态值的子进程的进程标识 ID；如果在等待过程中出现了错误（如已经没有可等待的子进程），那么wait()将返回 -1**。==**注意，父进程直接不能等待子进程的子进程！**==

`waitpid()`函数：

```c++
pid_t waitpid(pid_t pid, int *stat_loc, int options);
```

`waitpid()`与`wait()`不同的一点在于你可以通过在`pid`参数里指定一个进程标识 ID 来等待一个有特定的进程标识 ID 的进程—— ==当`pid`为一个大于零的数的时候`waitpid`等待的就是进程标识 ID 等于`pid`的子进程；== **当`pid`为 -1 时，我们等待所有子进程中的任何一个；** **当`pid`为 0 时，我们等待所有进程组标识 ID 与父进程相同的子进程；**==当`pid`小于 −1 时，我们任何进程组标识 ID 为 `pid` 的绝对值的进程。==

当 options 被设为 0 时，`waitpid `没有任何特殊选项。因此，我们可以知道，当`pid`为 -1−1、options为 0 时，`waitpid()`与`wait()`效果相同。

**总代码：**

```c++
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main() {
    printf("%s\n", "我是鸣人！");
    int pid = fork();
    if (pid != 0) {
        int status;
        int result = wait(&status);
        if (result == -1 || status != 0) {
            printf("%s\n", "可恶，又失败了，再来一次！");
            return -1;
        } else {
        	printf("%s\n", "我负责性质变化！");
        }
    } else {
        int second_pid = fork();
        if (second_pid != 0) {
            int new_status;
            int new_result = wait(&new_status);
            if (new_result == -1 || new_status != 0) {
            	exit(-1);   
            } else {
            	printf("%s\n", "我负责形态变化！");
            	exit(0);
            }
        } else {
            printf("%s\n", "我负责产生查克拉！");
            exit(0);
        } 
    }
    
    return 0;
}
```



## 四、`exec()`类函数

### 1.`execve()`系统调用函数

利用`fork()`返回的进程标识 ID，我们可以在子进程中执行和父进程中不同的指令；但如果我们想要==运行完全不同的程序==，这种办法可能就不是最好的。因此我们在此向你介绍一个新的系统调用，`execve()`。

在 Linux 系统中，我们实际比起系统调用本身更经常使用`exec()`组包含的六个函数，但此处我们先了解系统调用的实际过程，介绍系统调用，然后再介绍这六个建立在系统调用基础上的函数。

```c++
int execve(const char* filename, char* const argv[], char* const envp[]);
```

`execve()`用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。

这个函数将==在现在运行的进程中==**以`argv`中存储的字符串为参数**， **运行由filename指向的可执行程序**，**并将`envp`中存储的“变量=数值”对作为环境变量代入这个程序**。根据传统，==`argv`中的第一个参数必须与filename一致，真正的参数从第二个开始。==**`execve`会以filename的程序覆盖现在进程中正在运行的程序**，==因此所有在`execve`函数之后的行都只会在`execve`失败之后被执行==，我们**可以通过在后面加入打印语句等方法标识`execve`运行失败**。

### 2.基于`execve()`的六个函数

基于`execve()`的还有六个函数他们都具有在现有的进程中打开某一个可执行文件、覆盖现有程序执行的功能。

```c++
int execl(const char* path, const char* arg, ...);
int execlp(const char* file, const char* arg, ...);
int execle(const char* path, const char* arg,
           ..., char* const envp[]);
int execv(const char* path, char* const argv[]);
int execvp(const char* file, char* const argv[]);
int execvpe(const char* file, char* const argv[],
            char* const envp[]);
```

 它们都具有系统调用功能，可将这些函数表示为：“`exec + l/v + p/e/pe`”，这六个函数主要有两处不同：

 第一处不同（l/v）——“l”类函数将所有参数作为一整个字符串代入，而“v”类函数将参数分别放入一个字符串数组中，将数组作参代入函数运行。

 第二处不同（`p/e/pe`）——包含 p的函数可以模仿计算机中壳功能，在“file”中不含“/”时使用环境变量 PATH 中的目录来寻找可执行文件，包含 e的函数可以像`execve`一样将“变量=数值”对作为环境变量代入程序。

所有上述函数的常见用法是先由当前运行的进程调用fork()产生新进程，然后在新进程中用exec()类函数运行新程序。

你可能会认为这样应用fork()复制了全部父进程的地址空间后又马上弃置不用、浪费了很多处理器时间。

但实际上 Linux 系统采用了 copy_on_write 技术，也就是说只有在某一个数据被修改时那个数据才会被实际复制到子进程的地址空间，所以当fork()之后直接运行exec()时，父进程的地址空间不会被复制过来。