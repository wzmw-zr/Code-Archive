# 2019.12.19

## 一、欧拉计划08——滑动窗口算法

**题目描述：**给定一个1000位的数字，找出其中具有最大连乘积的13位连续数字，该连乘积最大为多少？

> 位数过多的数，可以使用数字数组或者字符数组来存储。
>
> 但是考虑到字符数组可以一位一位地读入，所以遇到大整数，一般使用字符数组存储。

**滑动窗口算法思想：**

遍历时不嵌套循环计算所有值，外层遍历相当于窗口向右滑动，每次除以去小下标值，乘上最新下标值，即为当前窗口的结果，然后再比较。

或者更加普遍地说，滑动窗口算法可以用于在遍历过程中重复运算与逆运算更新当前值的问题，消除内层循环。

换句话说，滑动窗口法可以使得$O(KN)$的时间复杂度降为$O(N)$级别。

>关于逆运算的判断，能够具备结合律的运算才可以有逆运算，并且一个运算的逆运算不一定具备逆运算。

**滑动窗口算法框架：**

(1)初始化 (2)元素移出窗口 (3)元素移入窗口 (4)滑动后处理

> 滑动窗口法需要注意特殊元素，特殊元素比如除法中的0需要单独判断处理
>
> 0可以使用一个计数器记录个数(其他特殊元素同理)



## 二、方向数组

**题目描述：**在下方20×20的方格中，要求同一方向上乘积最大的四个相邻数字(上、下、左、右、对角线)。

**方向数组：**

1.方向数组里存储了k个向量(**这代表方向的个数**)

2.每个向量有n维(一般n为2)[这代表某一个方向上单位向量的维数]

3.每个向量代表某个方向上的单位偏移量

>第一维代表方向个数，第二维代表维数，实际上第一维的数字代表某一轴上的偏移，第二维的数字也是如此。
>
>根据对称性减少方向个数。
>
>利用方向数组记录方向偏移量。
>
>如何用方向数组处理方向。

==方向数组适用于可移动方向受限制，并且个数有限的移动或者搜索类问题==

```c
#include<iostream>
#include<cstdio>
#define MAX_N 20
using namespace std;

int grid[MAX_N + 5][MAX_N + 5] = {0};

int dir[4][2] = {
    {-1, -1}, {-1, 0},
    {-1, 1}, {0, 1}
};
// 重点：方向数组处理方向向量
int calc(int x, int y) {
    int ans = 0;
    for (int k = 0; k < 4; k++) {
        int p = 1;
        for (int step = 0; step < 4; step++) {
            int dx = x + step * dir[k][0];
            int dy = y + step * dir[k][1];
            // 防止超过边界
            if (dx < 0 || dx >= MAX_N) break;
            if (dy < 0 || dy >= MAX_N) break;
            p *= grid[dx][dy];
        }
        if (p > ans) ans = p;
    }
    return ans;
} 

int main() {
    int ans = 0;
    for (int i = 0; i < MAX_N; i++) {
        for (int j = 0; j < MAX_N; j++) {
            scanf("%d", &grid[i][j]);
        }
    } 

    for (int i = 0; i < MAX_N; i++) {
        for (int j = 0; j < MAX_N; j++) {
            int p = calc(i, j);
            if (p > ans) ans = p;
        }
    }
    printf("%d\n", ans);
    return 0; 
}

```

